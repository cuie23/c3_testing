projection_type: "C3+"

solve_time_filter_alpha: 0.0
#set to 0 to publish as fast as possible
publish_frequency: 100
state_prediction_joints: []

quaternion_indices: [5]
quaternion_weight: 1000
quaternion_regularizer_fraction: 0.0

x_init: [0, 0, -0.07,
        0, 0,    
        1, 0, 0, 0, 
        -0, 0, 0,
        #-0.2, 0.2, -0.8, 
        0, 0, 0,
        0, 0,  
        0, 0, 0, 
        0, 0, 0]

x_des: [0, 0, 0,
        0, 0,
        #1, 0, 0, 0, 
        0.707, 0, 0.707, 0, 
        #0, 0.707, 0, 0.707,
        #0, 0, 1, 0,
        -0, 0, 0.0, 
        0, 0, 0,
        0, 0,
        0, 0, 0, 
        0, 0, 0]

lcs_factory_options:
  #options are 'stewart_and_trinkle' or 'anitescu'
  # contact_model : 'stewart_and_trinkle'
  contact_model: "anitescu"
  num_friction_directions: 2
  num_contacts: 8
  spring_stiffness: 0
  mu: [0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6]
  #mu: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
  N: 80
  dt: 0.02

c3_options:
  penalize_input_change: true

  warm_start: false
  end_on_qp_step: false
  scale_lcs: false

  num_threads: 10
  delta_option: 1

  M: 1000

  admm_iter: 5

  gamma: 1.0
  rho_scale: 1.1 #matrix scaling
  w_Q: 5
  w_R: 1 #Penalty on all decision variables, assuming scalar
  w_G: 2 #Penalty on all decision variables, assuming scalar
  w_U: 1 #State Tracking Error, assuming diagonal


  q_vector: [1, 1, 1,                # plate pos
             1, 1,                    # plate rot
             1, 1, 1, 1,    # cube rot
             300, 300, 300,           # cube pos              
             1, 1, 1,                # plate velo
             1, 1,                    # plate ang velo
             0.1, 0.1, 0.1,             # cube ang velo
             1, 1, 1]                # cube velo

  r_vector: [0.01, 0.01, 0.01, 0.01, 0.01]  
  #r_vector: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01] 
  
  #Penalty on matching projected variables
  g_x: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  g_u: [0, 0, 0, 0, 0] 
  
  g_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]


  #Penalty on matching the QP variables
  u_x: [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
  u_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  u_u: [0, 0, 0, 0, 0]

  u_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]