projection_type: "C3+"

solve_time_filter_alpha: 0.0
#set to 0 to publish as fast as possible
publish_frequency: 100
state_prediction_joints: []

quaternion_indices: [5]
Q_quaternion_weight: 5000
G_quaternion_weight: 20   # Unused
U_quaternion_weight: 100  # Unused

quaternion_regularizer_fraction: 0.0

x_init: [0, 0, -0.02,
        0, 0,    
        1, 0, 0, 0, 
        -0.13, 0, 0,
        #-0.2, 0.2, -0.8, 
        0, 0, 0,
        0, 0,  
        0, 0, 0, 
        0, 0, 0]

x_des: [0, 0, 0,
        0, 0,
        #0.707, 0, 0.707, 0, 
        0, 0, 1, 0,
        0, 0, 0, 
        0, 0, 0,
        0, 0,
        0, 0, 0, 
        0, 0, 0]

lcs_factory_options:
  #options are 'stewart_and_trinkle' or 'anitescu'
  # contact_model : 'stewart_and_trinkle'
  contact_model: "anitescu"
  num_friction_directions: 2
  num_contacts: 8
  spring_stiffness: 0
  mu: [0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6]
  #mu: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
  N: 60
  dt: 0.01

c3_options:
  penalize_input_change: false # Currently combines u-u_prev and u-u_des


  warm_start: false
  end_on_qp_step: true
  scale_lcs: false

  num_threads: 10
  delta_option: 1

  M: 1000

  admm_iter: 6

  gamma: 1.03
  rho_scale: 1.1 #matrix scaling
  w_Q: 5
  w_R: 0.1 #Penalty on all decision variables, assuming scalar
  w_G: 18 #Penalty on all decision variables, assuming scalar
  w_U: 5 #State Tracking Error, assuming diagonal


  q_vector: [500, 500, 500,                # plate pos
             300, 300,                    # plate rot
             1, 1, 1, 1,    # cube rot
             400, 400, 100,           # cube pos              
             5, 5, 1,                # plate velo
             10, 10,                    # plate ang velo
             5, 5, 5,             # cube ang velo
             1, 1, 1]                # cube velo

  r_vector: [40, 40, 10, 20, 20]  
  
  #Penalty on matching projected variables
  g_x: [10, 10, 10, 50, 50, 10, 10, 10, 10, 10, 10, 10, 1 , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  g_u: [0, 0, 0, 0, 0] 
  
  g_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]


  #Penalty on matching the QP variables
  u_x: [10, 10, 10, 50, 50, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
  u_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  u_u: [1, 1, 1, 1, 1]

  u_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]