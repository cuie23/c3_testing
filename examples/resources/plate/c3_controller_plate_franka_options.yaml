projection_type: "C3+"

solve_time_filter_alpha: 0.0
#set to 0 to publish as fast as possible
publish_frequency: 100
state_prediction_joints: []

quaternion_indices: [7]
Q_quaternion_weight: 5000
G_quaternion_weight: 20   # Unused
U_quaternion_weight: 100  # Unused

quaternion_regularizer_fraction: 0.0

x_init: [-1.66, 1.6, 1.93, -1.78, 1.62, 1.93, -0.12, 
         1, 0, 0, 0, 
         0.63, -0.35, 0.81,
         0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0]

x_des: [-1.66, 1.6, 1.93, -1.78, 1.62, 1.93, -0.12, 
        #0, 0, 1, 0,
        1, 0, 0, 0, 
        0.63, -0.35, 0.61,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0]

lcs_factory_options:
  #options are 'stewart_and_trinkle' or 'anitescu'
  # contact_model : 'stewart_and_trinkle'
  contact_model: "anitescu"
  num_friction_directions: 2
  num_contacts: 8
  spring_stiffness: 0
  mu: [0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6]
  #mu: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
  N: 120
  dt: 0.01

c3_options:
  penalize_input_change: false # Currently combines u-u_prev and u-u_des


  warm_start: false
  end_on_qp_step: true
  scale_lcs: false

  num_threads: 10
  delta_option: 1

  M: 1000

  admm_iter: 6

  gamma: 1.00
  rho_scale: 1.1 #matrix scaling
  w_Q: 5
  w_R: 0.005 #Penalty on all decision variables, assuming scalar
  w_G: 15 #Penalty on all decision variables, assuming scalar
  w_U: 3 #State Tracking Error, assuming diagonal


  q_vector: [10, 10, 10, 10, 10, 10, 10,    # franka joint diff from nominal
             1, 1, 1, 1,                    # cube rot (overwritten)
             500, 500, 300,                 # cube pos
             10, 10, 10, 10, 10, 10, 10,    # franka joint velo
             1, 1, 1, 1, 1, 1]              # cube velo

  r_vector: [1, 1, 1, 1, 1, 1, 1]  
  #r_vector: [0.01, 0.01, 0.01, 0.01, 0.01, 0.01] 
  
  #Penalty on matching projected variables
  g_x: [1, 1, 1, 1, 1, 1, 1, 
        30, 30, 30, 30, 10, 10, 10, 
        1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1]
  g_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  g_u: [1, 1, 1, 1, 1, 1, 1] 
  
  g_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  g_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  g_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]


  #Penalty on matching the QP variables
  u_x: [10, 10, 10, 10, 10, 10, 10, 
        30, 30, 30, 30, 10, 10, 10, 
        10, 10, 10, 10, 10, 10, 10, 
        10, 10, 10, 10, 10, 10]
  u_gamma: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_lambda: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
  u_u: [1, 1, 1, 1, 1, 1, 1]

  u_eta_slack: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_n: [1, 1, 1, 1, 1, 1, 1, 1]
  u_eta_t: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  u_eta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]